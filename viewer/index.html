<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Viewer</title>

    <!-- MapLibre GL CSS -->
    <link rel="stylesheet" href="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css" />

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            height: 100vh;
            overflow: hidden;
            display: flex;
        }

        #sidebar {
            width: 350px;
            background: #2c3e50;
            color: #ecf0f1;
            padding: 20px;
            overflow-y: auto;
            box-shadow: 2px 0 5px rgba(0,0,0,0.1);
            z-index: 1;
        }

        #map {
            flex: 1;
            height: 100vh;
        }

        h1 {
            font-size: 20px;
            margin-bottom: 20px;
            color: #3498db;
        }

        h2 {
            font-size: 16px;
            margin-top: 20px;
            margin-bottom: 10px;
            color: #3498db;
            border-bottom: 1px solid #34495e;
            padding-bottom: 5px;
        }

        .gpkg-select {
            width: 100%;
            padding: 8px;
            margin-bottom: 15px;
            background: #34495e;
            color: #ecf0f1;
            border: 1px solid #4a5f7f;
            border-radius: 4px;
            font-size: 14px;
        }

        .layer-item {
            padding: 10px;
            margin: 5px 0;
            background: #34495e;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .layer-item:hover {
            background: #4a5f7f;
        }

        .layer-item.active {
            background: #3498db;
        }

        .layer-checkbox {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .layer-info {
            flex: 1;
        }

        .layer-name {
            font-weight: 500;
            margin-bottom: 2px;
            color: #FFFFFF;
        }

        .layer-count {
            font-size: 12px;
            color: #95a5a6;
        }

        .color-indicator {
            width: 20px;
            height: 20px;
            border-radius: 3px;
            border: 2px solid #ecf0f1;
        }

        .no-layers {
            color: #95a5a6;
            font-style: italic;
            padding: 10px;
            text-align: center;
        }

        .loading {
            color: #3498db;
            padding: 10px;
            text-align: center;
        }

        .controls {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #34495e;
        }

        .btn {
            width: 100%;
            padding: 8px;
            margin: 5px 0;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s;
        }

        .btn:hover {
            background: #2980b9;
        }

        .btn:disabled {
            background: #7f8c8d;
            cursor: not-allowed;
        }

        .view-controls {
            margin-top: 15px;
        }

        .view-control-label {
            font-size: 12px;
            color: #95a5a6;
            margin-bottom: 5px;
        }

        .slider-container {
            margin: 10px 0;
        }

        .slider {
            width: 100%;
            margin: 5px 0;
        }

        .slider-value {
            font-size: 11px;
            color: #95a5a6;
            text-align: right;
        }

        /* MapLibre popup styling */
        .maplibregl-popup-content {
            padding: 10px;
            max-width: 300px;
        }

        .popup-table {
            width: 100%;
            border-collapse: collapse;
        }

        .popup-table td {
            padding: 5px;
            border-bottom: 1px solid #ddd;
        }

        .popup-table td:first-child {
            font-weight: bold;
            padding-right: 10px;
        }

        .api-key-input {
            width: 100%;
            padding: 6px;
            margin: 10px 0;
            background: #34495e;
            color: #ecf0f1;
            border: 1px solid #4a5f7f;
            border-radius: 4px;
            font-size: 12px;
        }

        .api-note {
            font-size: 11px;
            color: #95a5a6;
            margin-top: 5px;
            line-height: 1.4;
        }

        .api-note a {
            color: #3498db;
        }
    </style>
</head>
<body>
    <div id="sidebar">
        <h1>üó∫Ô∏è Viewer</h1>

        <div>
            <label for="gpkg-select" style="display: block; margin-bottom: 5px; font-size: 14px;">
                Select GeoPackage:
            </label>
            <select id="gpkg-select" class="gpkg-select">
                <option value="">Loading...</option>
            </select>
        </div>

        <h2>Layers</h2>
        <div id="layers-list" class="loading">
            Select a GeoPackage to view layers
        </div>

        <div class="controls">
            <button id="fit-bounds-btn" class="btn" disabled>Fit to Visible Layers</button>
            <button id="clear-all-btn" class="btn" disabled>Clear All Layers</button>

            <div class="view-controls">
                <div class="view-control-label">Camera Controls:</div>
                <button id="reset-north-btn" class="btn">Reset North</button>
                <button id="toggle-3d-btn" class="btn">Toggle 3D View</button>

                <div class="slider-container">
                    <label for="pitch-slider" style="font-size: 12px; color: #ecf0f1;">Pitch (Tilt):</label>
                    <input type="range" id="pitch-slider" class="slider" min="0" max="60" value="0">
                    <div class="slider-value"><span id="pitch-value">0</span>¬∞</div>
                </div>

                <div class="slider-container">
                    <label for="bearing-slider" style="font-size: 12px; color: #ecf0f1;">Bearing (Rotation):</label>
                    <input type="range" id="bearing-slider" class="slider" min="0" max="360" value="0">
                    <div class="slider-value"><span id="bearing-value">0</span>¬∞</div>
                </div>
            </div>
        </div>

    </div>

    <div id="map"></div>

    <!-- MapLibre GL JS -->
    <script src="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.js"></script>

    <script>
        // API key management
        let apiKey = '';

        // Initialize map with MapLibre GL
        const map = new maplibregl.Map({
            container: 'map',
            style: apiKey ?
                `https://api.maptiler.com/maps/streets-v2/style.json?key=${apiKey}` :
                {
                    version: 8,
                    sources: {
                        'osm': {
                            type: 'raster',
                            tiles: ['https://a.tile.openstreetmap.org/{z}/{x}/{y}.png'],
                            tileSize: 256,
                            attribution: '¬© OpenStreetMap contributors'
                        }
                    },
                    layers: [{
                        id: 'osm',
                        type: 'raster',
                        source: 'osm',
                        minzoom: 0,
                        maxzoom: 19
                    }]
                },
            center: [0, 0],
            zoom: 2,
            pitch: 0,
            bearing: 0,
            antialias: true
        });

        // Add navigation controls
        map.addControl(new maplibregl.NavigationControl(), 'top-right');
        map.addControl(new maplibregl.ScaleControl(), 'bottom-right');

        // Store loaded layers
        const loadedLayers = new Map();
        const layerSources = new Map();

        // Color palette for layers
        const colors = [
            '#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6',
            '#1abc9c', '#e67e22', '#34495e', '#16a085', '#27ae60'
        ];

        let colorIndex = 0;

        function getNextColor() {
            const color = colors[colorIndex % colors.length];
            colorIndex++;
            return color;
        }

        // View control functions
        document.getElementById('reset-north-btn').addEventListener('click', () => {
            map.easeTo({ bearing: 0, pitch: 0, duration: 1000 });
        });

        let is3D = false;
        document.getElementById('toggle-3d-btn').addEventListener('click', () => {
            is3D = !is3D;
            if (is3D) {
                map.easeTo({ pitch: 60, duration: 1000 });
            } else {
                map.easeTo({ pitch: 0, duration: 1000 });
            }
        });

        // Pitch slider
        const pitchSlider = document.getElementById('pitch-slider');
        const pitchValue = document.getElementById('pitch-value');
        pitchSlider.addEventListener('input', (e) => {
            const pitch = parseInt(e.target.value);
            map.setPitch(pitch);
            pitchValue.textContent = pitch;
        });

        // Bearing slider
        const bearingSlider = document.getElementById('bearing-slider');
        const bearingValue = document.getElementById('bearing-value');
        bearingSlider.addEventListener('input', (e) => {
            const bearing = parseInt(e.target.value);
            map.setBearing(bearing);
            bearingValue.textContent = bearing;
        });

        // Update sliders when map moves
        map.on('move', () => {
            const pitch = Math.round(map.getPitch());
            const bearing = Math.round(map.getBearing());
            pitchSlider.value = pitch;
            pitchValue.textContent = pitch;
            bearingSlider.value = bearing;
            bearingValue.textContent = bearing;
        });

        // Load GeoPackages
        async function loadGeoPackages() {
            try {
                const response = await fetch('/api/geopackages');
                const gpkgs = await response.json();

                const select = document.getElementById('gpkg-select');
                select.innerHTML = '<option value="">-- Select a GeoPackage --</option>';

                gpkgs.forEach(gpkg => {
                    const option = document.createElement('option');
                    option.value = gpkg;
                    option.textContent = gpkg;
                    select.appendChild(option);
                });

                if (gpkgs.length === 1) {
                    select.value = gpkgs[0];
                    loadLayers(gpkgs[0]);
                }
            } catch (error) {
                console.error('Error loading GeoPackages:', error);
                document.getElementById('gpkg-select').innerHTML =
                    '<option value="">Error loading files</option>';
            }
        }

        // Load layers from selected GeoPackage
        async function loadLayers(gpkgPath) {
            const layersList = document.getElementById('layers-list');
            layersList.innerHTML = '<div class="loading">Loading layers...</div>';

            try {
                const response = await fetch(`/api/layers/${encodeURIComponent(gpkgPath)}`);
                const layers = await response.json();

                if (layers.length === 0) {
                    layersList.innerHTML = '<div class="no-layers">No layers found</div>';
                    return;
                }

                layersList.innerHTML = '';

                layers.forEach(layer => {
                    const layerDiv = document.createElement('div');
                    layerDiv.className = 'layer-item';

                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.className = 'layer-checkbox';
                    checkbox.id = `layer-${layer.name}`;

                    const colorIndicator = document.createElement('div');
                    colorIndicator.className = 'color-indicator';
                    const layerColor = getNextColor();
                    colorIndicator.style.backgroundColor = layerColor;

                    const infoDiv = document.createElement('div');
                    infoDiv.className = 'layer-info';
                    infoDiv.innerHTML = `
                        <div class="layer-name">${layer.name}</div>
                        <div class="layer-count">${layer.feature_count} features</div>
                    `;

                    layerDiv.appendChild(checkbox);
                    layerDiv.appendChild(colorIndicator);
                    layerDiv.appendChild(infoDiv);

                    layerDiv.addEventListener('click', (e) => {
                        if (e.target !== checkbox) {
                            checkbox.checked = !checkbox.checked;
                            checkbox.dispatchEvent(new Event('change'));
                        }
                    });

                    checkbox.addEventListener('change', async () => {
                        if (checkbox.checked) {
                            await loadLayerData(gpkgPath, layer.name, layerColor);
                            layerDiv.classList.add('active');
                        } else {
                            removeLayer(layer.name);
                            layerDiv.classList.remove('active');
                        }
                        updateControls();
                    });

                    layersList.appendChild(layerDiv);
                });
            } catch (error) {
                console.error('Error loading layers:', error);
                layersList.innerHTML = '<div class="no-layers">Error loading layers</div>';
            }
        }

        // Load layer data
        async function loadLayerData(gpkgPath, layerName, color) {
            try {
                const response = await fetch(
                    `/api/layer/${encodeURIComponent(gpkgPath)}/${encodeURIComponent(layerName)}`
                );
                const geojson = await response.json();

                const sourceId = `source-${layerName}`;
                const layerId = `layer-${layerName}`;

                // Check if source already exists, if so remove the layer first
                if (map.getSource(sourceId)) {
                    console.log('Source already exists, removing old layer first');
                    removeLayer(layerName);
                }

                // Add source
                map.addSource(sourceId, {
                    type: 'geojson',
                    data: geojson
                });

                // Determine geometry type from first feature
                const firstFeature = geojson.features[0];
                const geomType = firstFeature ? firstFeature.geometry.type : 'Polygon';

                // Add appropriate layer based on geometry type
                if (geomType === 'Point' || geomType === 'MultiPoint') {
                    map.addLayer({
                        id: layerId,
                        type: 'circle',
                        source: sourceId,
                        paint: {
                            'circle-radius': 5,
                            'circle-color': color,
                            'circle-stroke-color': '#fff',
                            'circle-stroke-width': 1,
                            'circle-opacity': 0.8
                        }
                    });
                } else if (geomType === 'LineString' || geomType === 'MultiLineString') {
                    map.addLayer({
                        id: layerId,
                        type: 'line',
                        source: sourceId,
                        paint: {
                            'line-color': color,
                            'line-width': 3,
                            'line-opacity': 0.8
                        }
                    });
                } else {
                    // Polygon - create both fill and outline layers
                    const fillId = `${layerId}-fill`;
                    const outlineId = `${layerId}-outline`;

                    map.addLayer({
                        id: fillId,
                        type: 'fill',
                        source: sourceId,
                        paint: {
                            'fill-color': color,
                            'fill-opacity': 0.3
                        }
                    });
                    map.addLayer({
                        id: outlineId,
                        type: 'line',
                        source: sourceId,
                        paint: {
                            'line-color': color,
                            'line-width': 2,
                            'line-opacity': 0.8
                        }
                    });

                    // Store fill and outline layer IDs
                    loadedLayers.set(`${layerName}-fill`, fillId);
                    loadedLayers.set(`${layerName}-outline`, outlineId);

                    // Add click handler for fill layer
                    map.on('click', fillId, (e) => {
                        const properties = e.features[0].properties;
                        let html = '<table class="popup-table">';
                        for (const [key, value] of Object.entries(properties)) {
                            if (value !== null && value !== undefined) {
                                html += `<tr><td>${key}</td><td>${value}</td></tr>`;
                            }
                        }
                        html += '</table>';

                        new maplibregl.Popup()
                            .setLngLat(e.lngLat)
                            .setHTML(html)
                            .addTo(map);
                    });

                    // Change cursor on hover for fill layer
                    map.on('mouseenter', fillId, () => {
                        map.getCanvas().style.cursor = 'pointer';
                    });
                    map.on('mouseleave', fillId, () => {
                        map.getCanvas().style.cursor = '';
                    });
                }

                loadedLayers.set(layerName, layerId);
                layerSources.set(layerName, sourceId);

                // Add click handler for popups (for points and lines)
                if (geomType !== 'Polygon' && geomType !== 'MultiPolygon') {
                    map.on('click', layerId, (e) => {
                        const properties = e.features[0].properties;
                        let html = '<table class="popup-table">';
                        for (const [key, value] of Object.entries(properties)) {
                            if (value !== null && value !== undefined) {
                                html += `<tr><td>${key}</td><td>${value}</td></tr>`;
                            }
                        }
                        html += '</table>';

                        new maplibregl.Popup()
                            .setLngLat(e.lngLat)
                            .setHTML(html)
                            .addTo(map);
                    });

                    // Change cursor on hover
                    map.on('mouseenter', layerId, () => {
                        map.getCanvas().style.cursor = 'pointer';
                    });
                    map.on('mouseleave', layerId, () => {
                        map.getCanvas().style.cursor = '';
                    });
                }

                // Fit bounds to first layer
                if (layerSources.size === 1) {
                    fitToGeoJSON(geojson);
                }
            } catch (error) {
                console.error('Error loading layer data:', error);
                alert(`Error loading layer: ${layerName}`);
            }
        }

        // Remove layer from map
        function removeLayer(layerName) {
            const layerId = loadedLayers.get(layerName);
            const sourceId = layerSources.get(layerName);

            // Remove fill layer for polygons (must be removed first)
            const fillId = `${layerId}-fill`;
            if (fillId && map.getLayer(fillId)) {
                map.removeLayer(fillId);
            }

            // Remove outline layer for polygons
            const outlineId = `${layerId}-outline`;
            if (outlineId && map.getLayer(outlineId)) {
                map.removeLayer(outlineId);
            }

            // Remove main layer (for points/lines)
            if (layerId && map.getLayer(layerId)) {
                map.removeLayer(layerId);
            }

            // Now remove the source after all layers are removed
            if (sourceId && map.getSource(sourceId)) {
                map.removeSource(sourceId);
            }

            loadedLayers.delete(layerName);
            loadedLayers.delete(`${layerName}-fill`);
            loadedLayers.delete(`${layerName}-outline`);
            layerSources.delete(layerName);
        }

        // Update control buttons
        function updateControls() {
            const fitBtn = document.getElementById('fit-bounds-btn');
            const clearBtn = document.getElementById('clear-all-btn');

            const hasLayers = layerSources.size > 0;
            fitBtn.disabled = !hasLayers;
            clearBtn.disabled = !hasLayers;
        }

        // Fit bounds to GeoJSON
        function fitToGeoJSON(geojson) {
            const bounds = new maplibregl.LngLatBounds();

            geojson.features.forEach(feature => {
                if (feature.geometry.type === 'Point') {
                    bounds.extend(feature.geometry.coordinates);
                } else if (feature.geometry.type === 'LineString') {
                    feature.geometry.coordinates.forEach(coord => bounds.extend(coord));
                } else if (feature.geometry.type === 'Polygon') {
                    feature.geometry.coordinates[0].forEach(coord => bounds.extend(coord));
                } else if (feature.geometry.type === 'MultiPolygon') {
                    feature.geometry.coordinates.forEach(polygon => {
                        polygon[0].forEach(coord => bounds.extend(coord));
                    });
                }
            });

            map.fitBounds(bounds, { padding: 50, duration: 1000 });
        }

        // Fit bounds to all visible layers
        async function fitToVisibleLayers() {
            if (layerSources.size === 0) return;

            const bounds = new maplibregl.LngLatBounds();

            for (const [layerName, sourceId] of layerSources.entries()) {
                const source = map.getSource(sourceId);
                if (source) {
                    const data = source._data;
                    data.features.forEach(feature => {
                        if (feature.geometry.type === 'Point') {
                            bounds.extend(feature.geometry.coordinates);
                        } else if (feature.geometry.type === 'LineString') {
                            feature.geometry.coordinates.forEach(coord => bounds.extend(coord));
                        } else if (feature.geometry.type === 'Polygon') {
                            feature.geometry.coordinates[0].forEach(coord => bounds.extend(coord));
                        } else if (feature.geometry.type === 'MultiPolygon') {
                            feature.geometry.coordinates.forEach(polygon => {
                                polygon[0].forEach(coord => bounds.extend(coord));
                            });
                        }
                    });
                }
            }

            if (!bounds.isEmpty()) {
                map.fitBounds(bounds, { padding: 50, duration: 1000 });
            }
        }

        // Clear all layers
        function clearAllLayers() {
            const layerNames = Array.from(layerSources.keys());
            layerNames.forEach(layerName => removeLayer(layerName));

            // Uncheck all checkboxes
            document.querySelectorAll('.layer-checkbox').forEach(cb => {
                cb.checked = false;
            });

            document.querySelectorAll('.layer-item').forEach(item => {
                item.classList.remove('active');
            });

            updateControls();
        }

        // Event listeners
        document.getElementById('gpkg-select').addEventListener('change', (e) => {
            if (e.target.value) {
                clearAllLayers();
                colorIndex = 0;
                loadLayers(e.target.value);
            }
        });

        document.getElementById('fit-bounds-btn').addEventListener('click', fitToVisibleLayers);
        document.getElementById('clear-all-btn').addEventListener('click', clearAllLayers);

        // Load GeoPackages on page load
        map.on('load', () => {
            loadGeoPackages();
        });
    </script>
</body>
</html>
